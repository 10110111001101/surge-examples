Clawpack git diffs...

===========
classic
===========
/Users/mandli/src/clawpack/classic

diff --git a/examples/acoustics_1d_example1/qinit.f90 b/examples/acoustics_1d_example1/qinit.f90
index 945d91f..b7b0fbf 100644
--- a/examples/acoustics_1d_example1/qinit.f90
+++ b/examples/acoustics_1d_example1/qinit.f90
@@ -16,6 +16,7 @@ subroutine qinit(meqn,mbc,mx,xlower,dx,q,maux,aux)
     real(kind=8) :: beta, xcell
     common /cqinit/ beta
  
+     print *, "stuff"
  
       do i=1,mx
          xcell = xlower + (i-0.5d0)*dx


===========
amrclaw
===========
/Users/mandli/src/clawpack/amrclaw



===========
clawutil
===========
/Users/mandli/src/clawpack/clawutil



===========
pyclaw
===========
/Users/mandli/src/clawpack/pyclaw



===========
visclaw
===========
/Users/mandli/src/clawpack/visclaw



===========
riemann
===========
/Users/mandli/src/clawpack/riemann

diff --git a/src/rpn2_layered_shallow_water.f90 b/src/rpn2_layered_shallow_water.f90
index 21589b5..d7adce5 100644
--- a/src/rpn2_layered_shallow_water.f90
+++ b/src/rpn2_layered_shallow_water.f90
@@ -82,8 +82,6 @@ subroutine rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,fwave,s,amdq,ap
     real(kind=8), dimension(num_layers) :: h_hat_l, h_hat_r
     real(kind=8) :: b_l, b_r, flux_transfer_l, flux_transfer_r, lambda(6)
 
-    ! real(kind=8) :: advected_speed, eta_l, eta_r, gamma_l, gamma_r, kappa_l, kappa_r, w_normal, w_transverse
-
     ! Solver variables
     integer :: num_dry_states
     real(kind=8), dimension(num_layers) :: eigen_h_l, eigen_h_r
@@ -237,7 +235,22 @@ subroutine rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,fwave,s,amdq,ap
             call solve_single_layer_rp(layer_index, h_l, h_r, hu_l, hu_r,      &
                                                     hv_l, hv_r, b_l, b_r,      &
                                                     fw, sw)
-
+            if (any(fw > 1d-12)) then
+                print *, "dry states: ", dry_state_l, dry_state_r
+                print *, "        left            |             right"
+                print *, "====================================================="
+                print "(2d16.8)", h_l(1), h_r(1)
+                print "(2d16.8)", hu_l(1), hu_r(1)
+                print "(2d16.8)", hv_l(1), hv_r(1)
+                print "(2d16.8)", h_l(2), h_r(2)
+                print "(2d16.8)", hu_l(2), hu_r(2)
+                print "(2d16.8)", hv_l(2), hv_r(2)
+                print "(2d16.8)", b_l, b_r
+                print *, " "
+                print "(3d16.8)", (fw(j, :), j=1,3)
+                print "(3d16.8)", sw
+                stop
+            end if
             ! Update speeds and waves
             ! Note that we represent all the waves in the first three arrays
             ! so it does not directly correspond to the two-layer case's wave
@@ -270,6 +283,8 @@ subroutine rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,fwave,s,amdq,ap
         !     *inundation_method* is used.
         ! ======================================================================
         else
+            stop "Should not see a two-layer problem here"
+
             ! By default fill in the eigen and flux evaluation states with their
             ! side values
             if (eigen_method == 1) then
@@ -301,9 +316,21 @@ subroutine rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,fwave,s,amdq,ap
             momentum_transfer = 0.d0
 
             ! ==================================================================
+            !  All-states are wet - (F F F F)
+            if (num_dry_states == 0) then
+
+                ! Nothing to do for eigenspace evaluation
+
+                ! Flux evaulation
+                momentum_transfer(1) =  g * rho(1) * h_ave(1) * (h_r(2) - h_l(2) + b_r - b_l)
+                momentum_transfer(2) = -g * rho(1) * h_ave(1) * (h_r(2) - h_l(2)) + g * rho(2) * h_ave(2) * (b_r - b_l)
+                flux_transfer_r = g * rho(1) * h_r(1) * h_r(2)
+                flux_transfer_l = g * rho(1) * h_l(1) * h_l(2)
+
+            ! ==================================================================
             !  Right state is completely dry - (F F T T)
-            if (.not. dry_state_l(1) .and. .not. dry_state_l(2) .and.          &
-                      dry_state_r(1) .and.       dry_state_r(2)) then
+            else if (.not. dry_state_l(1) .and. .not. dry_state_l(2) .and.     &
+                           dry_state_r(1) .and.       dry_state_r(2)) then
     
                 ! Inundation occurs
                 inundation = sum(h_l) + b_l > b_r
@@ -450,20 +477,6 @@ subroutine rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,fwave,s,amdq,ap
                 end if
 
             ! ==================================================================
-            !  All-states are wet - (F F F F)
-!             else if (.not. dry_state_l(1) .and. .not. dry_state_l(2) .and.     &
-!                      .not. dry_state_r(1) .and. .not. dry_state_r(2)) then
-            else if (num_dry_states == 0) then
-
-                ! Nothing to do for eigenspace evaluation
-
-                ! Flux evaulation
-                momentum_transfer(1) =  g * rho(1) * h_ave(1) * (h_r(2) - h_l(2) + b_r - b_l)
-                momentum_transfer(2) = -g * rho(1) * h_ave(1) * (h_r(2) - h_l(2)) + g * rho(2) * h_ave(2) * (b_r - b_l)
-                flux_transfer_r = g * rho(1) * h_r(1) * h_r(2)
-                flux_transfer_l = g * rho(1) * h_l(1) * h_l(2)
-
-            ! ==================================================================
             !  We do not yet handle this case - F F F F and F F F F 
             else
                 print *, "Unhandled dry-state condition reached."
@@ -868,6 +881,24 @@ subroutine solve_single_layer_rp(layer_index, h_l, h_r, hu_l, hu_r, hv_l, hv_r,
             phiL = 0.d0
          endif
 
+         if (uL < 1e-14) then
+            huL = 0.d0
+            uL = 0.d0
+         end if
+         if (uR < 1e-14) then
+            huR = 0.d0
+            uR = 0.d0
+        end if
+
+         if (vL < 1e-14) then
+            hvL = 0.d0
+            vL = 0.d0
+         end if
+         if (vR < 1e-14) then
+            hvR = 0.d0
+            vR = 0.d0
+        end if
+
          wall(1) = 1.d0
          wall(2) = 1.d0
          wall(3) = 1.d0
@@ -922,14 +953,14 @@ subroutine solve_single_layer_rp(layer_index, h_l, h_r, hu_l, hu_r, hv_l, hv_r,
 
          maxiter = 1
 
-         call riemann_aug_JCP(maxiter,3,3,hL,hR,huL,huR,hvL,hvR,bL,bR,uL,uR, &
-                                          vL,vR,phiL,phiR,sE1,sE2,drytol,g,sw,fw)
+         ! call riemann_aug_JCP(maxiter,3,3,hL,hR,huL,huR,hvL,hvR,bL,bR,uL,uR, &
+         !                                  vL,vR,phiL,phiR,sE1,sE2,drytol,g,sw,fw)
 
 !         call riemann_ssqfwave(maxiter,meqn,mwaves,hL,hR,huL,huR,
 !     &     hvL,hvR,bL,bR,uL,uR,vL,vR,phiL,phiR,sE1,sE2,drytol,g,sw,fw)
 
-!          call riemann_fwave(meqn,mwaves,hL,hR,huL,huR,hvL,hvR,
-!     &      bL,bR,uL,uR,vL,vR,phiL,phiR,sE1,sE2,drytol,g,sw,fw)
+         call riemann_fwave(3,3,hL,hR,huL,huR,hvL,hvR,bL,bR,uL,uR, &
+                                         vL,vR,phiL,phiR,sE1,sE2,drytol,g,sw,fw)
 
 !        !eliminate ghost fluxes for wall
          do mw=1,3


===========
geoclaw
===========
/Users/mandli/src/clawpack/geoclaw

diff --git a/examples/multi-layer/plane_wave/setplot.py b/examples/multi-layer/plane_wave/setplot.py
index 04d83e0..689954d 100644
--- a/examples/multi-layer/plane_wave/setplot.py
+++ b/examples/multi-layer/plane_wave/setplot.py
@@ -122,15 +122,17 @@ def setplot(plotdata=None,  bathy_location=0.15,  bathy_angle=0.0,
 
     # ========================================================================
     # Axis limits
-    #xlimits = [amrdata.xlower,amrdata.xupper]
-    xlimits = [-0.5,0.5]
-    #ylimits = [amrdata.ylower,amrdata.yupper]
-    ylimits = [-0.5,0.5]
-    eta = [multilayer_data.eta[0],multilayer_data.eta[1]]
-    top_surface_limits = [eta[0]-0.03,eta[0]+0.03]
-    internal_surface_limits = [eta[1]-0.015,eta[1]+0.015]
+    xlimits = [clawdata.lower[0],clawdata.upper[0]]
+    # xlimits = [-0.5,0.5]
+    ylimits = [clawdata.lower[1],clawdata.upper[1]]
+    # ylimits = [-0.5,0.5]
+    eta = [multilayer_data.eta[0], multilayer_data.eta[1]]
+    # top_surface_limits = [eta[0]-0.03, eta[0]+0.03]
+    # internal_surface_limits = [eta[1]-0.015,eta[1]+0.015]
     # top_surface_limits = [eta[0]-0.3,eta[0]+0.3]
     # internal_surface_limits = [eta[1]-0.15,eta[1]+0.15]
+    top_surface_limits = [eta[0]-1e-15,eta[0]+1e-15]
+    internal_surface_limits = [eta[1]-1e-15,eta[1]+1e-15]
     top_speed_limits = [0.0,0.1]
     internal_speed_limits = [0.0,0.03]
     
diff --git a/examples/multi-layer/plane_wave/setrun.py b/examples/multi-layer/plane_wave/setrun.py
index 239c961..a7900be 100644
--- a/examples/multi-layer/plane_wave/setrun.py
+++ b/examples/multi-layer/plane_wave/setrun.py
@@ -242,7 +242,7 @@ def setrun(claw_pkg='geoclaw'):
     # Order of accuracy:  1 => Godunov,  2 => Lax-Wendroff plus limiters
     clawdata.order = 2
     
-    # Use dimensional splitting? (not yet available for AMR)
+    # Use dimensional splitting?
     #  0 or 'unsplit' or none'  ==> Unsplit
     #  1 or 'increment'         ==> corner transport of waves
     #  2 or 'all'               ==> corner transport of 2nd order corrections too
@@ -266,6 +266,7 @@ def setrun(claw_pkg='geoclaw'):
     #   3 or 'mc'       ==> MC limiter
     #   4 or 'vanleer'  ==> van Leer
     clawdata.limiter = ['mc', 'mc', 'mc', 'mc', 'mc', 'mc']
+    # clawdata.limiter = ['none', 'none', 'none', 'none', 'none', 'none']
 
     clawdata.use_fwaves = True    # True ==> use f-wave version of algorithms
     
@@ -469,9 +470,9 @@ def set_multilayer(rundata):
 
     # Physics parameters
     data.num_layers = 2
-    data.rho = [0.9,1.0]
-    data.eta = [0.0,-0.6]
-    
+    data.rho = [1.0, 1.1]
+    data.eta = [0.0, -1.1]
+
     # Algorithm parameters
     data.eigen_method = 2
     data.inundation_method = 2
@@ -481,7 +482,8 @@ def set_multilayer(rundata):
 
     rundata.replace_data('qinit_data', QinitMultilayerData())
     rundata.qinit_data.qinit_type = 6
-    rundata.qinit_data.epsilon = 0.02
+    # rundata.qinit_data.epsilon = 0.02
+    rundata.qinit_data.epsilon = 0.0
     rundata.qinit_data.angle = 0.0
     rundata.qinit_data.sigma = 0.02
     rundata.qinit_data.wave_family = 4
@@ -532,4 +534,4 @@ if __name__ == '__main__':
 
     rundata.write()
 
-    write_topo_file(rundata, 'topo.tt2')
+    write_topo_file(rundata, 'topo.tt2', right=-1.0)
diff --git a/src/2d/shallow/multilayer/setaux.f90 b/src/2d/shallow/multilayer/setaux.f90
index 2f4682d..168efbb 100644
--- a/src/2d/shallow/multilayer/setaux.f90
+++ b/src/2d/shallow/multilayer/setaux.f90
@@ -12,19 +12,21 @@ subroutine setaux(mbc,mx,my,xlow,ylow,dx,dy,maux,aux)
 !     aux(4:num_layers + 3,i,j) = Initial layer depths for linearized problem
 !
 
-    use amr_module, only: mcapa, xupper, yupper, xlower, ylower
+    use amr_module, only: mcapa, xupper, yupper, xlower, ylower, NEEDS_TO_BE_SET
 
     use geoclaw_module, only: coordinate_system, earth_radius, deg2rad
     use geoclaw_module, only: sea_level
 
-    use storm_module, only: storm_type, wind_index, pressure_index
+    use storm_module, only: wind_forcing, pressure_forcing
+    use storm_module, only: wind_index, pressure_index, set_storm_fields
     use storm_module, only: ambient_pressure
 
-    use friction_module, only: friction_index, set_friction_field
-
-    use multilayer_module, only: eta_init, num_layers, aux_layer_index
+    use friction_module, only: variable_friction, friction_index
+    use friction_module, only: set_friction_field
 
     use topo_module
+
+    use multilayer_module, only: eta_init, num_layers, aux_layer_index
     
     implicit none
     
@@ -34,7 +36,7 @@ subroutine setaux(mbc,mx,my,xlow,ylow,dx,dy,maux,aux)
     real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
     
     ! Locals
-    integer :: i,j,m,iint,jint
+    integer :: i,j,m,i_index,j_index,skipcount,ilo,jlo
     real(kind=8) :: x,y,xm,ym,xp,yp,topo_integral
     character(len=*), parameter :: aux_format = "(2i4,4d15.3)"
 
@@ -48,16 +50,18 @@ subroutine setaux(mbc,mx,my,xlow,ylow,dx,dy,maux,aux)
         endif
     endif
     
-    ! Set default values for aux variables
-    aux(1,:,:) = 0.d0 ! Bathymetry
-    aux(2,:,:) = 1.d0 ! Grid cell area
-    aux(3,:,:) = 1.d0 ! Length ratio for edge
-    aux(friction_index,:,:) = 0.d0 ! Manning's-N friction coefficeint
-    if (storm_type > 0) then
-        ! Set these to something non-offensive
-        aux(wind_index,:,:) = 0.d0 ! Wind speed x-direction
-        aux(wind_index+1,:,:) = 0.d0 ! Wind speed y-direction
-        aux(pressure_index,:,:) = ambient_pressure ! Pressure field
+    ! If using a variable friction field initialize the coefficients to 0
+    if (variable_friction) then
+        aux(friction_index,:,:) = 0.d0
+    endif
+
+    ! Storm fields if used
+    if (wind_forcing) then
+        aux(wind_index, :, :) = 0.d0
+        aux(wind_index + 1, :, :) = 0.d0
+    endif
+    if (pressure_forcing) then
+        aux(pressure_index, :, :) = ambient_pressure
     endif
     ! Initial layer depths for multilayer
     aux(aux_layer_index:num_layers - 1 + aux_layer_index,:,:) = 0.d0 
@@ -70,28 +74,54 @@ subroutine setaux(mbc,mx,my,xlow,ylow,dx,dy,maux,aux)
         end forall
     endif
     
+! test:  compute integer indices based off same corner of domain 
+!        to reduce round off discrepancies
+    ilo = floor((xlow - xlower + .05d0*dx)/dx)
+    jlo = floor((ylow - ylower + .05d0*dy)/dy)
+
     ! Set bathymetry
+    skipcount = 0
     do j=1-mbc,my+mbc
-        ym = ylow + (j - 1.d0) * dy
-        y = ylow + (j - 0.5d0) * dy
-        yp = ylow + real(j,kind=8) * dy
+        !ym = ylow + (j - 1.d0) * dy
+        !y = ylow + (j - 0.5d0) * dy
+        !yp = ylow + real(j,kind=8) * dy
+
+        ym = ylower + (jlo+j-1.d0) * dy
+        yp = ylower + (jlo+j) * dy
+        y = 0.5d0*(ym+yp)
+
+
         do i=1-mbc,mx+mbc
-            xm = xlow + (i - 1.d0) * dx
-            x = xlow + (i - 0.5d0) * dx
-            xp = xlow + real(i,kind=8) * dx
+            !xm = xlow + (i - 1.d0) * dx
+            !x  = xlow + (i - 0.5d0) * dx
+            !xp = xlow + real(i,kind=8) * dx
+
+            xm = xlower + (ilo+i-1.d0) * dx
+            xp = xlower + (ilo+i) * dx
+            x = 0.5d0*(xm+xp)
+
+
+            !write(*,"("in setaux ",2i4,e12.5)")i,j,aux(1,i,j)
 
             ! Set lat-long cell info
             if (coordinate_system == 2) then
                 aux(2,i,j) = deg2rad * earth_radius**2 * (sin(yp * deg2rad) - sin(ym * deg2rad)) / dy
                 aux(3,i,j) = ym * deg2rad
             endif
-            
+
             ! skip setting aux(1,i,j) in ghost cell if outside physical domain
             ! since topo files may not cover ghost cell, and values
             ! should be extrapolated, which is done in next set of loops.
             if ((y>yupper) .or. (y<ylower) .or. &
                 (x>xupper) .or. (x<xlower)) cycle
 
+!           ### parameter NEEDS_TO_BE_SET initialized in amr_module.f90
+!           ### saves time by otherwise copying instead of reinitializing
+            if (aux(1,i,j) .ne. NEEDS_TO_BE_SET) then
+               skipcount = skipcount + 1
+               cycle  ! new system copies bathy where possible
+            endif
+
 
             ! Use input topography files if available
             if (mtopofiles > 0 .and. test_topography == 0) then
@@ -101,35 +131,42 @@ subroutine setaux(mbc,mx,my,xlow,ylow,dx,dy,maux,aux)
                     mxtopo,mytopo,mtopo,i0topo,mtopoorder, &
                     mtopofiles,mtoposize,topowork)
 
+                if (coordinate_system == 2) then
                     aux(1,i,j) = topo_integral / (dx * dy * aux(2,i,j))
+                else
+                    aux(1,i,j) = topo_integral / (dx * dy)
+                endif
             endif
         enddo
     enddo
+    !write(*,*)" skipcount = ",skipcount
 
     ! Copy topo to ghost cells if outside physical domain
     do j=1-mbc,my+mbc
-        y = ylow + (j-0.5d0) * dy
+        y = ylower + (jlo+j-.5d0) * dy
         if ((y < ylower) .or. (y>yupper)) then
             do i=1-mbc,mx+mbc
-                x = xlow + (i-0.5d0) * dx 
-                iint = i + max(0, ceiling((xlower-x)/dx)) &
-                         - max(0, ceiling((x-xupper)/dx))
-                jint = j + max(0, ceiling((ylower-y)/dy)) &
-                         - max(0, ceiling((y-yupper)/dy))
-                aux(1,i,j) = aux(1,iint,jint)
+                x = xlower + (ilo+i-.5d0) * dx
+                i_index = i + max(0, ceiling((xlower-x)/dx)) &
+                            - max(0, ceiling((x-xupper)/dx))
+                j_index = j + max(0, ceiling((ylower-y)/dy)) &
+                            - max(0, ceiling((y-yupper)/dy))
+                aux(1,i,j) = aux(1,i_index,j_index)
             enddo
         endif
     enddo
+
+
     do i=1-mbc,mx+mbc
-        x = xlow + (i-0.5d0) * dx
+        x =  xlower + (ilo+i-.5d0) * dx
         if ((x < xlower) .or. (x > xupper)) then
             do j=1-mbc,my+mbc
-                y = ylow + (j-0.5d0) * dy 
-                iint = i + max(0, ceiling((xlower-x)/dx)) &
-                         - max(0, ceiling((x-xupper)/dx))
-                jint = j + max(0, ceiling((ylower-y)/dy)) &
-                         - max(0, ceiling((y-yupper)/dy))
-                aux(1,i,j) = aux(1,iint,jint)
+                y = ylower + (jlo+j-.5d0) * dy
+                i_index = i + max(0, ceiling((xlower-x)/dx)) &
+                            - max(0, ceiling((x-xupper)/dx))
+                j_index = j + max(0, ceiling((ylower-y)/dy)) &
+                            - max(0, ceiling((y-yupper)/dy))
+                aux(1,i,j) = aux(1,i_index,j_index)
             enddo
         endif
     enddo
diff --git a/src/python/geoclaw/data.py b/src/python/geoclaw/data.py
index 3e61103..e1923fc 100755
--- a/src/python/geoclaw/data.py
+++ b/src/python/geoclaw/data.py
@@ -91,9 +91,8 @@ class GeoClawData(clawpack.clawutil.data.ClawData):
         self.data_write()
 
         self.data_write('dry_tolerance')
- 
-        self.close_data_file()
 
+        self.close_data_file()
 
 
 class RefinementData(clawpack.clawutil.data.ClawData):
@@ -525,4 +524,58 @@ class MultilayerData(clawpack.clawutil.data.ClawData):
         # self.data_write('wave_tolerance',description='(Tolerance for wave height refinement)')
         # self.data_write('dry_limit',description='(Turn off limiting when near a dry state)')
         
-        self.close_data_file()
\ No newline at end of file
+        self.close_data_file()
+
+
+# ====================
+#  New Region Support
+# ====================
+class RegionData(clawpack.clawutil.data.ClawData):
+    r"""Region data object that is responsible for all region data output"""
+
+    def __init__(self):
+        r""""""
+
+        pass
+
+    def write(self, data_source="setrun.py"):
+        r""" """
+
+        pass
+
+
+class Region(object):
+    r"""Generic region definition, should be subclassed"""
+
+    def __init__(self):
+        r""""""
+
+        pass
+
+    def write(self):
+        r""""""
+
+        pass
+
+
+def TopoRegion(RegionData):
+    r"""Generic region specified by isobathys rather than lat-long boxes"""
+
+    def __init__(self):
+        r""""""
+
+        pass
+
+
+class RefinementRegion(Region):
+    r"""Region that defined a refinement criteria"""
+
+    def __init__(self):
+
+        pass
+
+    def write(self):
+        r""""""
+
+        pass
+
diff --git a/src/python/geoclaw/surge/plot.py b/src/python/geoclaw/surge/plot.py
index ccc43b4..2190b5c 100755
--- a/src/python/geoclaw/surge/plot.py
+++ b/src/python/geoclaw/surge/plot.py
@@ -499,7 +499,8 @@ def add_land(plotaxes,plot_type='pcolor',topo_min=-10,topo_max=10.0):
         plotitem.patchedges_show = 0   
 
 def add_bathy_contours(plotaxes,contour_levels=None,color='k'):
-    plotitem = plotaxes.new_plotitem(plot_type='2d_contour')
+    plotitem = plotaxes.new_plotitem(name="bathy_contours", 
+                                     plot_type='2d_contour')
     plotitem.plot_var = geoplot.topo
     if contour_levels is None:
         contour_levels = [0.0]
